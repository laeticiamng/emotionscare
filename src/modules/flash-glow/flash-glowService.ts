/**
 * Flash Glow Service - Gestion des sessions de luminoth√©rapie
 */

import { supabase } from '@/integrations/supabase/client';
import { sessionsService, SessionsAuthError } from '@/services/sessions.service';

export interface FlashGlowSession {
  duration_s: number;
  label: 'gain' | 'l√©ger' | 'incertain';
  glow_type?: string;
  intensity?: number;
  result?: 'completed' | 'interrupted';
  mood_before?: number | null;
  mood_after?: number | null;
  mood_delta?: number | null;
  metadata?: Record<string, any>;
}

export interface FlashGlowResponse {
  success: boolean;
  message: string;
  next_session_in?: string;
}

export interface FlashGlowStats {
  total_sessions: number;
  avg_duration: number;
  recent_sessions: any[];
}

class FlashGlowService {
  /**
   * D√©marrer une session Flash Glow
   */
  async startSession(config: {
    glowType: string;
    intensity: number;
    duration: number;
  }): Promise<{ sessionId: string }> {
    console.log('üåü Flash Glow session started:', config);
    
    // Simuler une session avec ID unique
    const sessionId = `fg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    return { sessionId };
  }

  /**
   * Terminer une session et envoyer les m√©triques
   */
  async endSession(sessionData: FlashGlowSession): Promise<FlashGlowResponse> {
    try {
      await sessionsService.logSession({
        type: 'flash_glow',
        durationSec: sessionData.duration_s,
        moodBefore: sessionData.mood_before ?? sessionData.metadata?.moodBefore ?? null,
        moodAfter: sessionData.mood_after ?? sessionData.metadata?.moodAfter ?? null,
        moodDelta: sessionData.mood_delta ?? sessionData.metadata?.moodDelta ?? null,
        meta: {
          label: sessionData.label,
          glowType: sessionData.glow_type ?? 'energy',
          intensity: sessionData.intensity ?? 0,
          ...(sessionData.metadata ?? {}),
        },
      });

      let metricsResponse: FlashGlowResponse | null = null;

      try {
        const { data, error } = await supabase.functions.invoke('flash-glow-metrics', {
          body: sessionData
        });

        if (error) {
          throw new Error(error.message || 'Erreur lors de l\'envoi des m√©triques');
        }

        metricsResponse = data;
      } catch (metricsError) {
        console.warn('‚ö†Ô∏è Flash Glow metrics tracking failed:', metricsError);
      }

      return metricsResponse ?? {
        success: true,
        message: 'Session enregistr√©e',
        next_session_in: undefined
      };
    } catch (error) {
      if (error instanceof SessionsAuthError) {
        console.warn('Flash Glow session logging skipped: user not authenticated');
      } else {
        console.error('‚ùå Flash Glow Service Error:', error);
      }
      throw error;
    }
  }

  /**
   * R√©cup√©rer les statistiques utilisateur
   */
  async getStats(): Promise<FlashGlowStats> {
    try {
      const { data: userData, error: userError } = await supabase.auth.getUser();

      if (userError || !userData?.user) {
        throw new Error(userError?.message || 'Utilisateur non authentifi√©');
      }

      const { data, error } = await supabase
        .from('sessions')
        .select('id, created_at, duration_sec, mood_delta, meta')
        .eq('user_id', userData.user.id)
        .eq('type', 'flash_glow')
        .order('created_at', { ascending: false })
        .limit(10);

      if (error) {
        throw new Error(error.message || 'Erreur lors de la r√©cup√©ration des sessions Flash Glow');
      }

      const totalSessions = data?.length ?? 0;
      const avgDuration = totalSessions
        ? Math.round(
          data!.reduce((acc, item) => acc + (item.duration_sec ?? 0), 0) / totalSessions
        )
        : 0;

      return {
        total_sessions: totalSessions,
        avg_duration: avgDuration,
        recent_sessions: data ?? []
      };
    } catch (error) {
      console.error('‚ùå Flash Glow Stats Error:', error);
      // Retourner des stats par d√©faut en cas d'erreur
      return {
        total_sessions: 0,
        avg_duration: 0,
        recent_sessions: []
      };
    }
  }

  /**
   * Trigger vibration si support√©
   */
  triggerHapticFeedback(pattern: number[] = [100, 50, 100]) {
    if ('vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }

  /**
   * Calculer le score bas√© sur la performance
   */
  calculateScore(duration: number, intensity: number, completed: boolean): number {
    let score = Math.floor(duration * 2); // Points de base
    
    if (intensity > 80) score += 20; // Bonus haute intensit√©
    if (completed) score += 50; // Bonus completion
    if (duration >= 90) score += 30; // Bonus longue session
    
    return Math.min(score, 300); // Cap √† 300 points
  }

  /**
   * Obtenir une recommandation bas√©e sur la performance
   */
  getRecommendation(label: FlashGlowSession['label'], streak: number): string {
    const recommendations = {
      'gain': [
        'Excellent ! Votre √©nergie rayonne ‚ú®',
        'Incroyable performance ! Vous brillez üåü',
        'Votre aura est √©clatante aujourd\'hui üí´'
      ],
      'l√©ger': [
        'Progr√®s en douceur, continuez üå±',
        'Chaque petit pas compte üåü',
        'Votre lumi√®re grandit doucement ‚ú®'
      ],
      'incertain': [
        'Chaque glow compte, f√©licitations üí´',
        'Votre pers√©v√©rance paiera üåü',
        'La magie op√®re m√™me en douceur ‚ú®'
      ]
    };

    const messages = recommendations[label];
    const baseMessage = messages[Math.floor(Math.random() * messages.length)];
    
    if (streak > 3) {
      return `${baseMessage}\nüî• Streak de ${streak} jours !`;
    }
    
    return baseMessage;
  }
}

export const flashGlowService = new FlashGlowService();