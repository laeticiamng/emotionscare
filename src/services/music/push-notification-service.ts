/**
 * Push Notification Service - Gestion des notifications web push
 * Service Worker, permissions, et notifications en temps r√©el
 */

import { logger } from '@/lib/logger';

interface PushNotificationOptions {
  title: string;
  body: string;
  icon?: string;
  badge?: string;
  tag?: string; // Group notifications
  requireInteraction?: boolean; // Requires user click to dismiss
  actions?: Array<{
    action: string;
    title: string;
    icon?: string;
  }>;
  data?: Record<string, any>;
}

interface PushPreference {
  enabled: boolean;
  permissionStatus: 'default' | 'granted' | 'denied';
  categories: {
    musicUpdates: boolean;
    achievements: boolean;
    recommendations: boolean;
    social: boolean;
    reminders: boolean;
  };
  quietHoursEnabled: boolean;
  quietHoursStart?: string; // HH:MM format
  quietHoursEnd?: string;
}

interface PushNotificationLog {\n  id: string;\n  title: string;\n  body: string;\n  sentTime: Date;\n  clicked: boolean;\n  clickedTime?: Date;\n  action?: string;\n}\n\nclass PushNotificationService {\n  private static instance: PushNotificationService;\n  private registration: ServiceWorkerRegistration | null = null;\n  private preferences: Map<string, PushPreference> = new Map();\n  private notificationLog: PushNotificationLog[] = [];\n  private isSupported: boolean;\n\n  private constructor() {\n    this.isSupported = 'serviceWorker' in navigator && 'PushManager' in window && 'Notification' in window;\n    this.loadFromLocalStorage();\n    logger.info('Push Notification Service initialized', { isSupported: this.isSupported }, 'PUSH_SERVICE');\n  }\n\n  static getInstance(): PushNotificationService {\n    if (!PushNotificationService.instance) {\n      PushNotificationService.instance = new PushNotificationService();\n    }\n    return PushNotificationService.instance;\n  }\n\n  /**\n   * Check if push notifications are supported\n   */\n  isNotificationSupported(): boolean {\n    return this.isSupported;\n  }\n\n  /**\n   * Register Service Worker\n   */\n  async registerServiceWorker(swPath: string = '/sw.js'): Promise<ServiceWorkerRegistration | null> {\n    if (!('serviceWorker' in navigator)) {\n      logger.warn('Service Worker not supported', {}, 'PUSH_SERVICE');\n      return null;\n    }\n\n    try {\n      this.registration = await navigator.serviceWorker.register(swPath);\n      logger.info('Service Worker registered', { path: swPath }, 'PUSH_SERVICE');\n      return this.registration;\n    } catch (error) {\n      logger.error('Failed to register Service Worker', error as Error, 'PUSH_SERVICE');\n      return null;\n    }\n  }\n\n  /**\n   * Request notification permission\n   */\n  async requestPermission(): Promise<NotificationPermission> {\n    if (!this.isSupported) {\n      logger.warn('Notifications not supported', {}, 'PUSH_SERVICE');\n      return 'denied';\n    }\n\n    try {\n      const permission = await Notification.requestPermission();\n      logger.info('Notification permission requested', { permission }, 'PUSH_SERVICE');\n      return permission;\n    } catch (error) {\n      logger.error('Failed to request notification permission', error as Error, 'PUSH_SERVICE');\n      return 'denied';\n    }\n  }\n\n  /**\n   * Check current permission status\n   */\n  getPermissionStatus(): NotificationPermission {\n    if (!this.isSupported) return 'denied';\n    return Notification.permission;\n  }\n\n  /**\n   * Set user preferences\n   */\n  setPreferences(userId: string, preferences: PushPreference): void {\n    this.preferences.set(userId, preferences);\n    this.saveToLocalStorage();\n    logger.info(`Push preferences updated for ${userId}`, { userId }, 'PUSH_SERVICE');\n  }\n\n  /**\n   * Get user preferences\n   */\n  getPreferences(userId: string): PushPreference {\n    return (\n      this.preferences.get(userId) || {\n        enabled: true,\n        permissionStatus: this.getPermissionStatus(),\n        categories: {\n          musicUpdates: true,\n          achievements: true,\n          recommendations: true,\n          social: false,\n          reminders: true,\n        },\n        quietHoursEnabled: false,\n      }\n    );\n  }\n\n  /**\n   * Check if in quiet hours\n   */\n  private isInQuietHours(preferences: PushPreference): boolean {\n    if (!preferences.quietHoursEnabled || !preferences.quietHoursStart || !preferences.quietHoursEnd) {\n      return false;\n    }\n\n    const now = new Date();\n    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now\n      .getMinutes()\n      .toString()\n      .padStart(2, '0')}`;\n\n    const start = preferences.quietHoursStart;\n    const end = preferences.quietHoursEnd;\n\n    if (start < end) {\n      return currentTime >= start && currentTime <= end;\n    } else {\n      return currentTime >= start || currentTime <= end;\n    }\n  }\n\n  /**\n   * Send a push notification\n   */\n  async sendNotification(\n    userId: string,\n    options: PushNotificationOptions\n  ): Promise<void> {\n    if (!this.isSupported) {\n      logger.warn('Push notifications not supported', {}, 'PUSH_SERVICE');\n      return;\n    }\n\n    const permission = this.getPermissionStatus();\n    if (permission !== 'granted') {\n      logger.warn('Push notification permission not granted', {}, 'PUSH_SERVICE');\n      return;\n    }\n\n    const preferences = this.getPreferences(userId);\n    if (!preferences.enabled || this.isInQuietHours(preferences)) {\n      logger.info('Push notification suppressed (quiet hours or disabled)', { userId }, 'PUSH_SERVICE');\n      return;\n    }\n\n    try {\n      const notification = new Notification(options.title, {\n        body: options.body,\n        icon: options.icon || '/icon-192.png',\n        badge: options.badge || '/badge-72.png',\n        tag: options.tag || 'default',\n        requireInteraction: options.requireInteraction || false,\n        data: options.data || {},\n      });\n\n      // Log notification\n      const logEntry: PushNotificationLog = {\n        id: `notif_${userId}_${Date.now()}`,\n        title: options.title,\n        body: options.body,\n        sentTime: new Date(),\n        clicked: false,\n      };\n\n      this.notificationLog.push(logEntry);\n\n      // Handle click\n      notification.onclick = () => {\n        logEntry.clicked = true;\n        logEntry.clickedTime = new Date();\n        window.focus();\n      };\n\n      logger.info(`Push notification sent to ${userId}`, { title: options.title }, 'PUSH_SERVICE');\n    } catch (error) {\n      logger.error('Failed to send push notification', error as Error, 'PUSH_SERVICE');\n    }\n  }\n\n  /**\n   * Subscribe to push notifications\n   */\n  async subscribeToPush(userId: string, serverPublicKey?: string): Promise<PushSubscription | null> {\n    if (!this.registration) {\n      logger.warn('Service Worker not registered', {}, 'PUSH_SERVICE');\n      return null;\n    }\n\n    try {\n      const subscription = await this.registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: serverPublicKey\n          ? this.urlBase64ToUint8Array(serverPublicKey)\n          : undefined,\n      });\n\n      logger.info(`User ${userId} subscribed to push notifications`, { userId }, 'PUSH_SERVICE');\n      return subscription;\n    } catch (error) {\n      logger.error('Failed to subscribe to push notifications', error as Error, 'PUSH_SERVICE');\n      return null;\n    }\n  }\n\n  /**\n   * Unsubscribe from push notifications\n   */\n  async unsubscribeFromPush(): Promise<boolean> {\n    if (!this.registration) return false;\n\n    try {\n      const subscription = await this.registration.pushManager.getSubscription();\n      if (subscription) {\n        await subscription.unsubscribe();\n        logger.info('Unsubscribed from push notifications', {}, 'PUSH_SERVICE');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      logger.error('Failed to unsubscribe from push notifications', error as Error, 'PUSH_SERVICE');\n      return false;\n    }\n  }\n\n  /**\n   * Get current subscription\n   */\n  async getSubscription(): Promise<PushSubscription | null> {\n    if (!this.registration) return null;\n\n    try {\n      return await this.registration.pushManager.getSubscription();\n    } catch (error) {\n      logger.error('Failed to get subscription', error as Error, 'PUSH_SERVICE');\n      return null;\n    }\n  }\n\n  /**\n   * Get notification log\n   */\n  getNotificationLog(userId?: string, limit: number = 50): PushNotificationLog[] {\n    return this.notificationLog.slice(-limit);\n  }\n\n  /**\n   * Get notification stats\n   */\n  getNotificationStats(): {\n    totalSent: number;\n    totalClicked: number;\n    clickRate: number;\n  } {\n    const totalSent = this.notificationLog.length;\n    const totalClicked = this.notificationLog.filter((n) => n.clicked).length;\n    const clickRate = totalSent > 0 ? (totalClicked / totalSent) * 100 : 0;\n\n    return {\n      totalSent,\n      totalClicked,\n      clickRate,\n    };\n  }\n\n  /**\n   * Clear notification log\n   */\n  clearNotificationLog(): void {\n    this.notificationLog = [];\n    this.saveToLocalStorage();\n    logger.info('Notification log cleared', {}, 'PUSH_SERVICE');\n  }\n\n  /**\n   * Convert VAPID key to Uint8Array\n   */\n  private urlBase64ToUint8Array(base64String: string): Uint8Array {\n    const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n    const base64 = (base64String + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n\n    return outputArray;\n  }\n\n  /**\n   * Save to localStorage\n   */\n  private saveToLocalStorage(): void {\n    try {\n      const data = {\n        preferences: Array.from(this.preferences.entries()),\n        notificationLog: this.notificationLog,\n      };\n      localStorage.setItem('music:push', JSON.stringify(data));\n    } catch (error) {\n      logger.error('Failed to save push data to localStorage', error as Error, 'PUSH_SERVICE');\n    }\n  }\n\n  /**\n   * Load from localStorage\n   */\n  private loadFromLocalStorage(): void {\n    try {\n      const stored = localStorage.getItem('music:push');\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.preferences = new Map(data.preferences || []);\n        this.notificationLog = data.notificationLog || [];\n      }\n    } catch (error) {\n      logger.error('Failed to load push data from localStorage', error as Error, 'PUSH_SERVICE');\n    }\n  }\n\n  /**\n   * Clear all data\n   */\n  clearAll(): void {\n    this.preferences.clear();\n    this.notificationLog = [];\n    localStorage.removeItem('music:push');\n    logger.info('Cleared all push notification data', {}, 'PUSH_SERVICE');\n  }\n}\n\nexport const pushNotificationService = PushNotificationService.getInstance();\nexport type { PushNotificationOptions, PushPreference, PushNotificationLog };
